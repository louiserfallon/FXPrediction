---
title: "BDF"
author: "Louise Fallon"
output:
  pdf_document: default
  html_document: default
---

```{r setup, include=FALSE}
library(readxl) #for read_excel
library(ggplot2) #for ggplot
library(reshape2) #for melt
library(knitr) #for kable
library(plyr) #for ddply
library(gridExtra) #for gridarrange
knitr::opts_chunk$set(echo = FALSE)
```


```{r}
##creating 1 df from each sheet in the variable construction
y <- read_excel("variable_construction.xlsx", sheet = 6)
X1 <- read_excel("variable_construction.xlsx", sheet = 7)
X2 <-read_excel("variable_construction.xlsx", sheet = 10)
X3 <-read_excel("variable_construction.xlsx", sheet = 9)
X4 <-read_excel("variable_construction.xlsx", sheet = 8)

##creating 9 dataframes (one for each currency) with the relevant variables
##and putting them into a list (need a list in order to loop)
dflist <- list()
#putting ys next to lagged xs
for (i in 1:9) dflist[[i]] <- data.frame(yt=y[2:nrow(y),i+1],
                          X1=X1[1:(nrow(y)-1),i+1],
                          X2=X2[1:(nrow(y)-1),i+1],
                          X3=X3[1:(nrow(y)-1),i+1],
                          X4=X4[1:(nrow(y)-1),i+1])
```

Results of a 20-window length rolling linear regression, including the MSE and the average value of each of the betas for each currency:

```{r}
windowlength <- 20

#initialise vectors to store average betas for each variable
meanx1beta <- vector()
meanx2beta <- vector()
meanx3beta <- vector()
meanx4beta <- vector()
MSE <- vector()

for (j in 1:9) {
prd.linear <- vector()
x1betas <- vector()
x2betas <- vector()
x3betas <- vector()
x4betas <- vector()
  
for (tau in windowlength:(nrow(dflist[[j]])-1)) {
#create model on training data within the window (up to tau)
      temp.mdl.linear <- lm(yt ~ ., data=dflist[[j]][(tau-windowlength+1):tau,])
#predict the tau+1th spot rate
      prd.linear <- c(prd.linear,predict(temp.mdl.linear, newdata=dflist[[j]][tau+1,2:5]))
#store the x1 beta so we can check later if the signs are usually correct
      x1betas <- c(x1betas,temp.mdl.linear$coefficients[2])
      x2betas <- c(x2betas,temp.mdl.linear$coefficients[3])
      x3betas <- c(x3betas,temp.mdl.linear$coefficients[4])
      x4betas <- c(x4betas,temp.mdl.linear$coefficients[5])}

#for each currency
#calculate the MSE, and add to vector
MSE <- c(MSE,(1/length(prd.linear))*sum((prd.linear-dflist[[j]][(windowlength+1):412,"yt"])^2))
#store the mean of the betas, and add to vector
meanx1beta <- c(meanx1beta, mean(x1betas))
meanx2beta <- c(meanx2beta, mean(x2betas))
meanx3beta <- c(meanx3beta, mean(x3betas))
meanx4beta <- c(meanx4beta, mean(x4betas))}

#display data frame of the MSE and average betas
betasdf <- data.frame(Currency=c("AUD","CAD","CHF",
                                 "EUR","GBP","JPY",
                                 "NOK","NZD","SEK"),
                      MSE=MSE,
                      meanx1beta=meanx1beta,
                      meanx2beta=meanx2beta,
                      meanx3beta=meanx3beta,
                      meanx4beta=meanx4beta)
kable(betasdf)
```

\newpage

Correlation plot of lagged X variables on Y variable for all currencies (can make this prettier if we want to use it, struggling to make the red text bold)

```{r fig.height=11, fig.align="center", fig.width=10}
plotlist <- list()
for (i in 1:9)
{
#get the name of the plot as the currency
plotname <- c("AUD","CAD","CHF",
              "EUR","GBP","JPY",
              "NOK","NZD","SEK")[i]

#melt data so that each y can be matched to each of the lagged variables
meltdf <- melt(dflist[[i]], id="yt")
#create plot with points and smoothed line
p <- ggplot(meltdf , aes(y=value, x=yt)) + geom_point(alpha=0.2) + geom_smooth() + facet_grid( variable ~ ., scales="free") + theme_light()
#add correlations
cors <- ddply(meltdf, .(variable), summarise, cor = round(cor(yt, value), 2))
#put correlations 25% of the way up the x axis of each plot
cors$yaxis <- c((max(dflist[[i]][["X1"]])-min(dflist[[i]][["X1"]]))/4
                +min(dflist[[i]][["X1"]]),
               (max(dflist[[i]][["X2"]])-min(dflist[[i]][["X2"]]))/4
                +min(dflist[[i]][["X2"]]),
               (max(dflist[[i]][["X3"]])-min(dflist[[i]][["X3"]]))/4
                +min(dflist[[i]][["X3"]]),
               (max(dflist[[i]][["X4"]])-min(dflist[[i]][["X4"]]))/4
                +min(dflist[[i]][["X4"]]))
#put correlations 1/8th of the way up the x axis of the plot
cors$xaxis <-  rep((max(dflist[[i]][["yt"]])-min(dflist[[i]][["yt"]]))/8 + min(dflist[[i]][["yt"]]),4)
#add correlations to the plot
p <- p + geom_text(data=cors, aes(label=cor, x=xaxis, y=yaxis, color="red")) + theme(legend.position="none", axis.text.x=element_blank(), axis.ticks.x=element_blank(), axis.text.y=element_blank(), axis.ticks.y=element_blank()) + ylab("") + ggtitle(plotname)
##add plot to the list
plotlist[[plotname]] <- p
}
grid.arrange(plotlist[["AUD"]],plotlist[["CAD"]],plotlist[["CHF"]],
             plotlist[["EUR"]],plotlist[["GBP"]],plotlist[["JPY"]],
             plotlist[["NOK"]],plotlist[["NZD"]],plotlist[["SEK"]], nrow=3)
```
